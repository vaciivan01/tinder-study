{"ast":null,"code":"import { useForm } from 'react-hook-form';\nimport fetch from 'isomorphic-unfetch';\nimport { createContext, useContext, createElement, useState, useEffect } from 'react';\nimport slugify from 'slugify';\nimport cheerio from 'cheerio';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar getFieldFromContext = function (context, id, type) {\n  if (context === null) {\n    throw new Error('You need to wrap your form with a GoogleFormProvider');\n  }\n\n  var field = context.getField(id);\n\n  if (field.type !== type) {\n    throw new Error(\"Field with id \" + field.id + \" is not of type \" + type);\n  }\n\n  return field;\n};\n\nvar _excluded = [\"children\"];\nvar GoogleFormContext = createContext(null);\n\nvar useGoogleFormContext = function useGoogleFormContext() {\n  return useContext(GoogleFormContext);\n};\n\nvar GoogleFormProvider = function GoogleFormProvider(_ref) {\n  var children = _ref.children,\n      other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return createElement(GoogleFormContext.Provider, {\n    value: other\n  }, children);\n};\n\nvar OTHER_OPTION = '__other_option__';\nvar OTHER_OPTION_RESPONSE = 'other_option_response';\n\nvar buildCustomFieldId = function buildCustomFieldId(id) {\n  return id + \"-\" + OTHER_OPTION_RESPONSE;\n};\n\nvar useCustomOptionField = function (id, type) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, type);\n\n  var _useState = useState(false),\n      isCustomOptionSelected = _useState[0],\n      setIsCustomOptionSelected = _useState[1];\n\n  var _useState2 = useState(false),\n      customInputRequired = _useState2[0],\n      setCustomInputRequired = _useState2[1];\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  var currentValue = context.watch(id);\n  useEffect(function () {\n    if (field.type === 'RADIO') {\n      var _isCustomOptionSelected = currentValue && currentValue === OTHER_OPTION;\n\n      setCustomInputRequired(field.required && _isCustomOptionSelected);\n      setIsCustomOptionSelected(_isCustomOptionSelected);\n    } else {\n      var _isCustomOptionSelected2 = currentValue && currentValue.length === 1 && currentValue.includes(OTHER_OPTION);\n\n      setCustomInputRequired(field.required && _isCustomOptionSelected2);\n      setIsCustomOptionSelected(_isCustomOptionSelected2);\n    }\n  }, [currentValue, customInputRequired]);\n  var nonCustomOptions = field.options.filter(function (o) {\n    return !o.custom;\n  });\n\n  var buildId = function buildId(value) {\n    return id + \"-\" + slugify(value);\n  };\n\n  var buildOptionRegister = function buildOptionRegister(o) {\n    var id = buildId(o.label);\n\n    var registerOption = function registerOption(options) {\n      return _extends({}, register(_extends({}, options)), {\n        value: o.label\n      });\n    };\n\n    return _extends({}, o, {\n      id: id,\n      registerOption: registerOption\n    });\n  };\n\n  var result = {\n    options: nonCustomOptions.map(buildOptionRegister)\n  };\n  var customOption = field.options.find(function (o) {\n    return o.custom;\n  });\n\n  if (customOption) {\n    var _id = buildId(OTHER_OPTION);\n\n    var registerOption = function registerOption(options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return _extends({}, register(_extends({}, options)), {\n        value: OTHER_OPTION\n      });\n    };\n\n    var customOptionId = buildCustomFieldId(_id);\n\n    var registerCustomInput = function registerCustomInput(options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return context.register(customOptionId, _extends({\n        required: customInputRequired\n      }, options));\n    };\n\n    var _error = context.formState.errors[customOptionId];\n    result.customOption = _extends({}, customOption, {\n      id: _id,\n      registerOption: registerOption,\n      registerCustomInput: registerCustomInput,\n      error: _error\n    });\n  }\n\n  var error = context.formState.errors[field.id];\n  return _extends({}, field, result, {\n    error: error,\n    isCustomOptionSelected: isCustomOptionSelected\n  });\n};\n\nvar GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d';\n\nvar formatQuestionName = function formatQuestionName(id) {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return \"entry.\" + id.replace(\"-\" + OTHER_OPTION + \"-\" + OTHER_OPTION_RESPONSE, '') + \".\" + OTHER_OPTION_RESPONSE;\n  }\n\n  return \"entry.\" + id;\n};\n\nvar submitToGoogleForms = function submitToGoogleForms(form, formData) {\n  try {\n    var urlParams = new URLSearchParams();\n    Object.keys(formData).forEach(function (key) {\n      if (formData[key]) {\n        if (formData[key].constructor === Array) {\n          formData[key].forEach(function (answer) {\n            urlParams.append(formatQuestionName(key), answer);\n          });\n        } else {\n          urlParams.append(formatQuestionName(key), formData[key]);\n        }\n      }\n    });\n    return Promise.resolve(fetch(GOOGLE_FORMS_URL + \"/\" + form.action + \"/formResponse?submit=Submit&\" + urlParams.toString(), {\n      method: 'GET',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    })).then(function (fetchedResult) {\n      var wasSuccessful = fetchedResult.ok && fetchedResult.status < 300 && fetchedResult.status >= 200;\n      return wasSuccessful;\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar resolveField = function resolveField(id, form) {\n  var fieldIndex = form.fieldsOrder[id];\n\n  if (fieldIndex === undefined) {\n    throw new Error(\"Field with id \" + id + \" wasn't found in your form\");\n  }\n\n  var field = form.fields[fieldIndex];\n  return field;\n};\n\nvar useGoogleForm = function useGoogleForm(_ref) {\n  var form = _ref.form;\n  var methods = useForm();\n\n  methods.getField = function (id) {\n    return resolveField(id, form);\n  };\n\n  methods.submitToGoogleForms = function (formData) {\n    return submitToGoogleForms(form, formData);\n  };\n\n  return methods;\n};\n\nvar useRadioInput = function useRadioInput(id) {\n  return useCustomOptionField(id, 'RADIO');\n};\n\nvar useCheckboxInput = function useCheckboxInput(id) {\n  return useCustomOptionField(id, 'CHECKBOX');\n};\n\nvar useTextInput = function (id, fieldType) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, fieldType);\n  var error = context.formState.errors[field.id];\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  return _extends({}, field, {\n    register: register,\n    error: error\n  });\n};\n\nvar useShortAnswerInput = function useShortAnswerInput(id) {\n  return useTextInput(id, 'SHORT_ANSWER');\n};\n\nvar useLongAnswerInput = function useLongAnswerInput(id) {\n  return useTextInput(id, 'LONG_ANSWER');\n};\n\nvar useGridInput = function (id, type) {\n  var context = useGoogleFormContext();\n\n  var _useState = useState(undefined),\n      errors = _useState[0],\n      setErrors = _useState[1];\n\n  var field = getFieldFromContext(context, id, type);\n\n  var buildId = function buildId(lineId, value) {\n    return id + \"-\" + lineId + \"-\" + slugify(value);\n  };\n\n  useEffect(function () {\n    var newErrors = field.lines.reduce(function (acc, l) {\n      var fieldError = context.formState.errors[l.id];\n\n      if (fieldError) {\n        acc[l.id] = fieldError;\n      }\n\n      return acc;\n    }, {});\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors);\n    } else {\n      setErrors(undefined);\n    }\n  }, [context.formState.errors]);\n\n  var renderGrid = function renderGrid(render) {\n    return field.lines.map(function (l) {\n      var registerLine = function registerLine(options) {\n        return context.register(l.id, _extends({\n          required: field.required\n        }, options));\n      };\n\n      var renderColumns = function renderColumns(render) {\n        return field.columns.map(function (c) {\n          var id = buildId(l.id, c.label);\n\n          var registerColumn = function registerColumn(options) {\n            return _extends({}, registerLine(options), {\n              value: c.label\n            });\n          };\n\n          return render(_extends({}, c, {\n            registerColumn: registerColumn,\n            id: id\n          }));\n        });\n      };\n\n      return render(_extends({}, l, {\n        renderColumns: renderColumns\n      }));\n    });\n  };\n\n  return _extends({}, field, {\n    renderGrid: renderGrid,\n    errors: errors\n  });\n};\n\nvar useCheckboxGridInput = function useCheckboxGridInput(id) {\n  return useGridInput(id, 'CHECKBOX_GRID');\n};\n\nvar useRadioGridInput = function useRadioGridInput(id) {\n  return useGridInput(id, 'RADIO_GRID');\n};\n\nvar useDropdownInput = function useDropdownInput(id) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, 'DROPDOWN');\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  var error = context.formState.errors[field.id];\n\n  var buildId = function buildId(value) {\n    return field.id + \"-\" + slugify(value);\n  };\n\n  var options = field.options.map(function (o) {\n    var id = buildId(o.label);\n    return _extends({}, o, {\n      id: id\n    });\n  });\n  return _extends({}, field, {\n    options: options,\n    register: register,\n    error: error\n  });\n};\n\nvar useLinearInput = function useLinearInput(id) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, 'LINEAR');\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  var buildId = function buildId(value) {\n    return field.id + \"-\" + slugify(value);\n  };\n\n  var error = context.formState.errors[field.id];\n  var options = field.options.map(function (o) {\n    var id = buildId(o.label);\n\n    var registerOption = function registerOption(options) {\n      return _extends({}, register(options), {\n        value: o.label\n      });\n    };\n\n    return _extends({}, o, {\n      id: id,\n      registerOption: registerOption\n    });\n  });\n  return _extends({}, field, {\n    options: options,\n    error: error\n  });\n}; // A type of promise-like that resolves synchronously and supports only one observer\n\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar toBool = function toBool(n) {\n  return n === 1;\n};\n\nvar toString = function toString(n) {\n  return \"\" + n;\n};\n\nvar assertValidUrl = function assertValidUrl(formUrl) {\n  var googleFormsHosts = ['docs.google.com', 'forms.gle'];\n  var url = new URL(formUrl);\n\n  if (!googleFormsHosts.includes(url.host)) {\n    throw new Error(\"Invalid google forms host. \" + url.host + \" is expected to be \" + googleFormsHosts.join(', ').replace(/, ([^,]*)$/, ' or $1') + \".\");\n  }\n\n  if (url.host === googleFormsHosts[0] && !url.pathname.endsWith('/viewform')) {\n    throw new Error(\"Please use the form's public URL.\");\n  }\n};\n\nvar getFormHtml = function getFormHtml(formUrl) {\n  try {\n    return Promise.resolve(fetch(formUrl)).then(function (response) {\n      return Promise.resolve(response.text());\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar extractFormData = function extractFormData(html) {\n  var $ = cheerio.load(html);\n  var fbzx = $('[name=\"fbzx\"]').attr('value');\n\n  if (!fbzx) {\n    throw new Error(\"Invalid form. Couldn't find fbzx field.\");\n  }\n\n  var scriptStringIdentifier = 'var FB_PUBLIC_LOAD_DATA_ =';\n  var scriptHtml = $('script').filter(function (_, el) {\n    return $(el).html().includes(scriptStringIdentifier);\n  }).first().html();\n\n  if (!scriptHtml) {\n    throw new Error(\"Invalid form. Couldn't find script tag.\");\n  }\n\n  scriptHtml = scriptHtml.replace(';', '');\n  scriptHtml = scriptHtml.replace(scriptStringIdentifier, '');\n  var formDataRaw = JSON.parse(scriptHtml);\n  return {\n    formData: formDataRaw,\n    fbzx: fbzx\n  };\n};\n\nvar parseGridMultiSelect = function parseGridMultiSelect(rawField) {\n  var firstLine = rawField[4][0];\n  var canSelectMultiple = firstLine[11][0];\n  return canSelectMultiple;\n};\n\nvar parseFieldType = function parseFieldType(rawField, fieldId) {\n  var fieldTypes = ['SHORT_ANSWER', 'LONG_ANSWER', 'RADIO', 'DROPDOWN', 'CHECKBOX', 'LINEAR'];\n\n  if (fieldId === 7) {\n    if (parseGridMultiSelect(rawField) === 1) {\n      return 'CHECKBOX_GRID';\n    } else {\n      return 'RADIO_GRID';\n    }\n  }\n\n  if (fieldId === 9) {\n    return 'DATE';\n  }\n\n  return fieldTypes[fieldId];\n};\n\nvar parseOptions = function parseOptions(options) {\n  return options.map(function (rawOption) {\n    return {\n      label: rawOption[0]\n    };\n  });\n};\n\nvar parseCustomizableOptions = function parseCustomizableOptions(options) {\n  return options.map(function (rawOption) {\n    return {\n      label: rawOption[0],\n      custom: rawOption[4] === 1\n    };\n  });\n};\n\nvar flattenArray = function flattenArray(array) {\n  return array.map(function (item) {\n    return {\n      label: item[0]\n    };\n  });\n};\n\nvar parseLines = function parseLines(lines) {\n  return lines.map(function (rawLine) {\n    var line = {};\n    line.id = toString(rawLine[0]);\n    line.label = rawLine[3][0];\n    return line;\n  });\n};\n\nvar parseField = function parseField(rawField) {\n  var field = {};\n  field.label = rawField[1];\n  field.description = rawField[2];\n  var fieldId = rawField[3];\n  field.type = parseFieldType(rawField, fieldId);\n\n  switch (field.type) {\n    case 'SHORT_ANSWER':\n    case 'LONG_ANSWER':\n      {\n        var fieldInfo = rawField[4][0];\n        field.id = toString(fieldInfo[0]);\n        field.required = toBool(fieldInfo[2]);\n        break;\n      }\n\n    case 'CHECKBOX':\n    case 'RADIO':\n      {\n        var _fieldInfo = rawField[4][0];\n        field.id = toString(_fieldInfo[0]);\n        field.options = parseCustomizableOptions(_fieldInfo[1]);\n        field.required = toBool(_fieldInfo[2]);\n        break;\n      }\n\n    case 'DROPDOWN':\n      {\n        var _fieldInfo2 = rawField[4][0];\n        field.id = toString(_fieldInfo2[0]);\n        field.options = parseOptions(_fieldInfo2[1]);\n        field.required = toBool(_fieldInfo2[2]);\n        break;\n      }\n\n    case 'LINEAR':\n      {\n        var _fieldInfo3 = rawField[4][0];\n        field.id = toString(_fieldInfo3[0]);\n        var _fieldInfo3$ = _fieldInfo3[3],\n            labelFirst = _fieldInfo3$[0],\n            labelLast = _fieldInfo3$[1];\n        field.legend = {\n          labelFirst: labelFirst,\n          labelLast: labelLast\n        };\n        field.options = flattenArray(_fieldInfo3[1]);\n        field.required = toBool(_fieldInfo3[2]);\n        break;\n      }\n\n    case 'CHECKBOX_GRID':\n    case 'RADIO_GRID':\n      {\n        field.id = toString(rawField[0]);\n        field.columns = flattenArray(rawField[4][0][1]);\n        field.lines = parseLines(rawField[4]);\n        field.required = toBool(rawField[4][0][2]);\n        break;\n      }\n\n    case 'DATE':\n      {\n        var _fieldInfo4 = rawField[4][0];\n        field.id = toString(_fieldInfo4[0]);\n        field.required = toBool(rawField[4][0][2]);\n        break;\n      }\n  }\n\n  return field;\n};\n\nvar parseFields = function parseFields(rawFields) {\n  var fieldsOrder = {};\n  var fields = rawFields.map(function (rawField, i) {\n    var field = parseField(rawField);\n    fieldsOrder[\"\" + field.id] = i;\n    return field;\n  });\n  return {\n    fields: fields,\n    fieldsOrder: fieldsOrder\n  };\n};\n\nvar parseFormData = function parseFormData(_ref) {\n  var formData = _ref.formData,\n      fbzx = _ref.fbzx;\n  var googleForm = {};\n  googleForm.fvv = 1;\n  googleForm.pageHistory = 0;\n  googleForm.fbzx = fbzx;\n  googleForm.action = formData[14];\n  googleForm.title = formData[1][8];\n  googleForm.description = formData[1][0];\n\n  var _parseFields = parseFields(formData[1][1]),\n      fields = _parseFields.fields,\n      fieldsOrder = _parseFields.fieldsOrder;\n\n  googleForm.fields = fields;\n  googleForm.fieldsOrder = fieldsOrder;\n  return googleForm;\n};\n\nvar googleFormsToJson = function googleFormsToJson(formUrl) {\n  try {\n    var _exit2 = false;\n\n    var _temp3 = function _temp3(_result) {\n      if (_exit2) return _result;\n      var formData = extractFormData(html);\n      return parseFormData(formData);\n    };\n\n    assertValidUrl(formUrl);\n    var html;\n\n    var _temp4 = _catch(function () {\n      return Promise.resolve(getFormHtml(formUrl)).then(function (_getFormHtml) {\n        html = _getFormHtml;\n      });\n    }, function (err) {\n      throw new Error(\"Failed to fetch form. \" + err);\n    });\n\n    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nexport { GOOGLE_FORMS_URL, GoogleFormProvider, formatQuestionName, googleFormsToJson, submitToGoogleForms, useCheckboxGridInput, useCheckboxInput, useDropdownInput, useGoogleForm, useGoogleFormContext, useLinearInput, useLongAnswerInput, useRadioGridInput, useRadioInput, useShortAnswerInput };","map":{"version":3,"mappings":"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","names":["context","id","type","Error","field","getField","GoogleFormContext","React","useGoogleFormContext","GoogleFormProvider","children","other","Provider","value","OTHER_OPTION","OTHER_OPTION_RESPONSE","buildCustomFieldId","getFieldFromContext","useState","isCustomOptionSelected","setIsCustomOptionSelected","customInputRequired","setCustomInputRequired","register","options","required","currentValue","watch","useEffect","length","includes","nonCustomOptions","filter","o","custom","buildId","slugify","buildOptionRegister","label","registerOption","result","map","customOption","find","customOptionId","registerCustomInput","error","formState","errors","GOOGLE_FORMS_URL","formatQuestionName","replace","submitToGoogleForms","form","formData","urlParams","URLSearchParams","Object","keys","forEach","key","constructor","Array","answer","append","fetch","action","toString","method","mode","headers","fetchedResult","wasSuccessful","ok","status","resolveField","fieldIndex","fieldsOrder","undefined","fields","useGoogleForm","methods","useForm","useRadioInput","useCustomOptionField","useCheckboxInput","fieldType","useShortAnswerInput","useTextInput","useLongAnswerInput","setErrors","lineId","newErrors","lines","reduce","acc","l","fieldError","renderGrid","render","registerLine","renderColumns","columns","c","registerColumn","useCheckboxGridInput","useGridInput","useRadioGridInput","useDropdownInput","useLinearInput","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_catch","body","recover","e","then","toBool","n","assertValidUrl","formUrl","googleFormsHosts","url","URL","host","join","pathname","endsWith","getFormHtml","response","text","extractFormData","html","$","cheerio","load","fbzx","attr","scriptStringIdentifier","scriptHtml","_","el","first","formDataRaw","JSON","parse","parseGridMultiSelect","rawField","firstLine","canSelectMultiple","parseFieldType","fieldId","fieldTypes","parseOptions","rawOption","parseCustomizableOptions","flattenArray","array","item","parseLines","rawLine","line","parseField","description","fieldInfo","labelFirst","labelLast","legend","parseFields","rawFields","i","parseFormData","googleForm","fvv","pageHistory","title","googleFormsToJson","err"],"sources":["/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/utils/getFieldFromContext.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useGoogleFormContext.tsx","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/utils/useCustomOptionField.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/scripts/submitToGoogleForms.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useGoogleForm.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useRadioInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useCheckboxInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/utils/useTextInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useShortAnswerInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useLongAnswerInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/utils/useGridInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useCheckboxGridInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useRadioGridInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useDropdownInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/hooks/useLinearInput.ts","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/node_modules/babel-plugin-transform-async-to-promises/helpers.js","/Users/ivanvaci/Downloads/personal/tinder-study/node_modules/react-google-forms-hooks/src/scripts/googleFormsToJson.ts"],"sourcesContent":["import { UseGoogleFormReturn, FieldTypes } from '../../types'\n\nexport default (\n  context: UseGoogleFormReturn | null,\n  id: string,\n  type: FieldTypes\n) => {\n  if (context === null) {\n    throw new Error('You need to wrap your form with a GoogleFormProvider')\n  }\n\n  const field = context.getField(id)\n\n  if (field.type !== type) {\n    throw new Error(`Field with id ${field.id} is not of type ${type}`)\n  }\n\n  return field\n}\n","import * as React from 'react'\nimport { UseGoogleFormReturn } from '../types'\n\nconst GoogleFormContext = React.createContext<UseGoogleFormReturn | null>(null)\nexport const useGoogleFormContext = () => React.useContext(GoogleFormContext)\n\nexport const GoogleFormProvider = ({\n  children,\n  ...other\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <GoogleFormContext.Provider value={other as UseGoogleFormReturn}>\n      {children}\n    </GoogleFormContext.Provider>\n  )\n}\n","import { useState, useEffect } from 'react'\nimport slugify from 'slugify'\n\nimport {\n  UseCustomOptionReturn,\n  Option,\n  BaseField,\n  UseCustomOptionField,\n  CustomOptionField\n} from '../../types'\nimport getFieldFromContext from './getFieldFromContext'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const OTHER_OPTION = '__other_option__'\nexport const OTHER_OPTION_RESPONSE = 'other_option_response'\n\nexport const buildCustomFieldId = (id: string) => {\n  return `${id}-${OTHER_OPTION_RESPONSE}`\n}\n\nexport default (\n  id: string,\n  type: 'CHECKBOX' | 'RADIO'\n): UseCustomOptionField => {\n  const context = useGoogleFormContext()\n  const field = getFieldFromContext(context, id, type) as CustomOptionField\n\n  const [isCustomOptionSelected, setIsCustomOptionSelected] =\n    useState<boolean>(false)\n  const [customInputRequired, setCustomInputRequired] = useState<boolean>(false)\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const currentValue = context!.watch(id)\n\n  useEffect(() => {\n    if (field.type === 'RADIO') {\n      const isCustomOptionSelected =\n        currentValue && currentValue === OTHER_OPTION\n      setCustomInputRequired(field.required && isCustomOptionSelected)\n      setIsCustomOptionSelected(isCustomOptionSelected)\n    } else {\n      const isCustomOptionSelected =\n        currentValue &&\n        currentValue.length === 1 &&\n        currentValue.includes(OTHER_OPTION)\n      setCustomInputRequired(field.required && isCustomOptionSelected)\n      setIsCustomOptionSelected(isCustomOptionSelected)\n    }\n  }, [currentValue, customInputRequired])\n\n  const nonCustomOptions = field.options.filter(\n    (o) => !o.custom\n  ) as Array<Option>\n\n  const buildId = (value: string) => {\n    return `${id}-${slugify(value)}`\n  }\n\n  const buildOptionRegister = (o: Option) => {\n    const id = buildId(o.label)\n    const registerOption = (options: RegisterOptions) => ({\n      ...register({ ...options }),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  }\n\n  const result = {\n    options: nonCustomOptions.map(buildOptionRegister)\n  } as UseCustomOptionReturn\n\n  const customOption = field.options.find((o) => o.custom) as Option\n  if (customOption) {\n    const id = buildId(OTHER_OPTION)\n    const registerOption = (options = {}) => ({\n      ...register({ ...options }),\n      value: OTHER_OPTION\n    })\n\n    const customOptionId = buildCustomFieldId(id)\n\n    const registerCustomInput = (options = {}) => {\n      return context!.register(customOptionId, {\n        required: customInputRequired,\n        ...options\n      })\n    }\n\n    const error = context!.formState.errors[customOptionId]\n\n    result.customOption = {\n      ...customOption,\n      id,\n      registerOption,\n      registerCustomInput,\n      error\n    }\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  return {\n    ...(field as BaseField),\n    ...result,\n    error,\n    isCustomOptionSelected\n  }\n}\n","import fetch from 'isomorphic-unfetch'\nimport { GoogleForm } from '../types'\nimport {\n  OTHER_OPTION,\n  OTHER_OPTION_RESPONSE\n} from '../hooks/utils/useCustomOptionField'\n\nexport const GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d'\n\nexport const formatQuestionName = (id: string) => {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return `entry.${id.replace(\n      `-${OTHER_OPTION}-${OTHER_OPTION_RESPONSE}`,\n      ''\n    )}.${OTHER_OPTION_RESPONSE}`\n  }\n\n  return `entry.${id}`\n}\n\nexport const submitToGoogleForms = async (\n  form: GoogleForm,\n  formData: object\n): Promise<boolean> => {\n  const urlParams = new URLSearchParams()\n  Object.keys(formData).forEach((key) => {\n    if (formData[key]) {\n      if (formData[key].constructor === Array) {\n        formData[key].forEach((answer: string) => {\n          urlParams.append(formatQuestionName(key), answer)\n        })\n      } else {\n        urlParams.append(formatQuestionName(key), formData[key])\n      }\n    }\n  })\n\n  const fetchedResult = await fetch(\n    `${GOOGLE_FORMS_URL}/${\n      form.action\n    }/formResponse?submit=Submit&${urlParams.toString()}`,\n    {\n      method: 'GET',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }\n  )\n\n  const wasSuccessful =\n    fetchedResult.ok &&\n    fetchedResult.status < 300 &&\n    fetchedResult.status >= 200\n\n  return wasSuccessful\n}\n","import { useForm } from 'react-hook-form'\nimport { GoogleForm, UseGoogleFormReturn } from '../types'\nimport { submitToGoogleForms } from '../scripts/submitToGoogleForms'\n\nconst resolveField = (id: string, form: GoogleForm) => {\n  const fieldIndex = form.fieldsOrder[id]\n\n  if (fieldIndex === undefined) {\n    throw new Error(`Field with id ${id} wasn't found in your form`)\n  }\n\n  const field = form.fields[fieldIndex]\n  return field\n}\n\nexport const useGoogleForm = ({ form }: { form: GoogleForm }) => {\n  const methods = useForm() as UseGoogleFormReturn\n\n  methods.getField = (id: string) => resolveField(id, form)\n\n  methods.submitToGoogleForms = (formData) =>\n    submitToGoogleForms(form, formData)\n\n  return methods\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useRadioInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'RADIO')\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useCheckboxInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'CHECKBOX')\n}\n","import { RegisterOptions } from 'react-hook-form'\n\nimport { UseTextFieldReturn, TextField } from '../../types'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\n\nexport default (\n  id: string,\n  fieldType: 'LONG_ANSWER' | 'SHORT_ANSWER'\n): UseTextFieldReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, fieldType) as TextField\n\n  const error = context!.formState.errors[field.id]\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  return { ...field, register, error }\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useShortAnswerInput = (id: string) => {\n  return useTextInput(id, 'SHORT_ANSWER')\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useLongAnswerInput = (id: string) => {\n  return useTextInput(id, 'LONG_ANSWER')\n}\n","import { useEffect, useState } from 'react'\nimport { RegisterOptions } from 'react-hook-form'\nimport slugify from 'slugify'\n\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\nimport {\n  UseGridFieldReturn,\n  GridField,\n  RenderLineFunction,\n  RenderColumnFunction,\n  GridErrors\n} from '../../types'\n\nexport default (\n  id: string,\n  type: 'RADIO_GRID' | 'CHECKBOX_GRID'\n): UseGridFieldReturn => {\n  const context = useGoogleFormContext()\n  const [errors, setErrors] = useState<GridErrors | undefined>(undefined)\n\n  const field = getFieldFromContext(context, id, type) as GridField\n\n  const buildId = (lineId: string, value: string) => {\n    return `${id}-${lineId}-${slugify(value)}`\n  }\n\n  useEffect(() => {\n    const newErrors: GridErrors = field.lines.reduce((acc: GridErrors, l) => {\n      const fieldError = context!.formState.errors[l.id]\n      if (fieldError) {\n        acc[l.id] = fieldError\n      }\n      return acc\n    }, {})\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors)\n    } else {\n      setErrors(undefined)\n    }\n  }, [context!.formState.errors])\n\n  const renderGrid = (render: RenderLineFunction): JSX.Element[] => {\n    return field.lines.map((l) => {\n      const registerLine = (options?: RegisterOptions) =>\n        context!.register(l.id, { required: field.required, ...options })\n\n      const renderColumns = (render: RenderColumnFunction): JSX.Element[] => {\n        return field.columns.map((c) => {\n          const id = buildId(l.id, c.label)\n          const registerColumn = (options?: RegisterOptions) => ({\n            ...registerLine(options),\n            value: c.label\n          })\n\n          return render({ ...c, registerColumn, id })\n        })\n      }\n\n      return render({ ...l, renderColumns })\n    })\n  }\n\n  return { ...field, renderGrid, errors }\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useCheckboxGridInput = (id: string) => {\n  return useGridInput(id, 'CHECKBOX_GRID')\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useRadioGridInput = (id: string) => {\n  return useGridInput(id, 'RADIO_GRID')\n}\n","import slugify from 'slugify'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseDropdownReturn, DropdownField } from '../types'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const useDropdownInput = (id: string): UseDropdownReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'DROPDOWN') as DropdownField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const error = context!.formState.errors[field.id]\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    return {\n      ...o,\n      id\n    }\n  })\n\n  return { ...field, options, register, error }\n}\n","import slugify from 'slugify'\nimport { RegisterOptions } from 'react-hook-form'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseLinearInputReturn, LinearField } from '../types'\n\nexport const useLinearInput = (id: string): UseLinearInputReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'LINEAR') as LinearField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    const registerOption = (options?: RegisterOptions) => ({\n      ...register(options),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  })\n\n  return { ...field, options, error }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import cheerio from 'cheerio'\nimport fetch from 'isomorphic-unfetch'\n\nimport {\n  Column,\n  CustomizableOption,\n  Field,\n  FieldsOrder,\n  GoogleForm,\n  Line,\n  Option\n} from '../types/form'\n\ntype FormData = {\n  formData: object\n  fbzx: string\n}\n\nconst toBool = (n: number): boolean => n === 1\n\nconst toString = (n: number): string => `${n}`\n\nconst assertValidUrl = (formUrl: string): void => {\n  const googleFormsHosts = ['docs.google.com', 'forms.gle']\n  const url = new URL(formUrl)\n\n  if (!googleFormsHosts.includes(url.host)) {\n    throw new Error(\n      `Invalid google forms host. ${\n        url.host\n      } is expected to be ${googleFormsHosts\n        .join(', ')\n        .replace(/, ([^,]*)$/, ' or $1')}.`\n    )\n  }\n\n  if (url.host === googleFormsHosts[0] && !url.pathname.endsWith('/viewform')) {\n    throw new Error(`Please use the form's public URL.`)\n  }\n}\n\nconst getFormHtml = async (formUrl: string) => {\n  const response = await fetch(formUrl)\n  const html = await response.text()\n  return html\n}\n\nconst extractFormData = (html: string): FormData => {\n  const $ = cheerio.load(html)\n  const fbzx = $('[name=\"fbzx\"]').attr('value')\n\n  if (!fbzx) {\n    throw new Error(`Invalid form. Couldn't find fbzx field.`)\n  }\n\n  const scriptStringIdentifier = 'var FB_PUBLIC_LOAD_DATA_ ='\n  let scriptHtml = $('script')\n    .filter((_, el) => {\n      return $(el).html()!.includes(scriptStringIdentifier)\n    })\n    .first()\n    .html()\n\n  if (!scriptHtml) {\n    throw new Error(`Invalid form. Couldn't find script tag.`)\n  }\n\n  scriptHtml = scriptHtml.replace(';', '')\n  scriptHtml = scriptHtml.replace(scriptStringIdentifier, '')\n\n  const formDataRaw = JSON.parse(scriptHtml)\n\n  return { formData: formDataRaw, fbzx }\n}\n\nconst parseGridMultiSelect = (rawField: Array<object>): 1 | 0 => {\n  const firstLine = rawField[4][0]\n  const canSelectMultiple = firstLine[11][0]\n\n  return canSelectMultiple\n}\n\nconst parseFieldType = (rawField: Array<object>, fieldId: number) => {\n  const fieldTypes = [\n    'SHORT_ANSWER',\n    'LONG_ANSWER',\n    'RADIO',\n    'DROPDOWN',\n    'CHECKBOX',\n    'LINEAR'\n  ] as const\n\n  if (fieldId === 7) {\n    if (parseGridMultiSelect(rawField) === 1) {\n      return 'CHECKBOX_GRID'\n    } else {\n      return 'RADIO_GRID'\n    }\n  }\n  if (fieldId === 9) {\n    return 'DATE'\n  }\n\n  return fieldTypes[fieldId]\n}\n\nconst parseOptions = (options: Array<object>): Array<Option> => {\n  return options.map((rawOption) => ({ label: rawOption[0] }))\n}\n\nconst parseCustomizableOptions = (\n  options: Array<object>\n): Array<CustomizableOption> => {\n  return options.map((rawOption) => ({\n    label: rawOption[0],\n    custom: rawOption[4] === 1\n  }))\n}\n\nconst flattenArray = (array: Array<Array<string>>): Array<Option | Column> => {\n  return array.map((item) => ({ label: item[0] }))\n}\n\nconst parseLines = (lines: Array<any>): Array<Line> => {\n  return lines.map((rawLine) => {\n    const line = {} as Line\n    line.id = toString(rawLine[0])\n    line.label = rawLine[3][0]\n    return line\n  })\n}\n\nconst parseField = (rawField: Array<any>): Field => {\n  const field = {} as Field\n\n  field.label = rawField[1]\n  field.description = rawField[2]\n\n  const fieldId = rawField[3]\n  field.type = parseFieldType(rawField, fieldId)\n\n  switch (field.type) {\n    case 'SHORT_ANSWER':\n    case 'LONG_ANSWER': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX':\n    case 'RADIO': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseCustomizableOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'DROPDOWN': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'LINEAR': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      const [labelFirst, labelLast] = fieldInfo[3]\n      field.legend = { labelFirst, labelLast }\n      field.options = flattenArray(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX_GRID':\n    case 'RADIO_GRID': {\n      field.id = toString(rawField[0])\n      field.columns = flattenArray(rawField[4][0][1])\n      field.lines = parseLines(rawField[4])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n    case 'DATE': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n  }\n\n  return field\n}\n\nconst parseFields = (\n  rawFields: Array<any>\n): { fields: Array<Field>; fieldsOrder: FieldsOrder } => {\n  const fieldsOrder = {}\n\n  const fields = rawFields.map((rawField: Array<any>, i: number) => {\n    const field = parseField(rawField)\n    fieldsOrder[`${field.id}`] = i\n    return field\n  })\n\n  return { fields, fieldsOrder }\n}\n\nconst parseFormData = ({ formData, fbzx }: FormData): GoogleForm => {\n  const googleForm = {} as GoogleForm\n\n  googleForm.fvv = 1\n  googleForm.pageHistory = 0\n  googleForm.fbzx = fbzx\n  googleForm.action = formData[14]\n  googleForm.title = formData[1][8]\n  googleForm.description = formData[1][0]\n\n  const { fields, fieldsOrder } = parseFields(formData[1][1])\n  googleForm.fields = fields\n  googleForm.fieldsOrder = fieldsOrder\n\n  return googleForm\n}\n\nexport const googleFormsToJson = async (formUrl: string) => {\n  assertValidUrl(formUrl)\n\n  let html\n  try {\n    html = await getFormHtml(formUrl)\n  } catch (err) {\n    throw new Error(`Failed to fetch form. ${err}`)\n  }\n\n  const formData = extractFormData(html)\n  return parseFormData(formData)\n}\n"]},"metadata":{},"sourceType":"module"}